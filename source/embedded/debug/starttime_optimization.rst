嵌入式linux启动时间优化
=========================

在linux系统中执行 ``man boot`` 可以看到有以下几个部分

1) hardware
2) operating system (OS) loader
3) kernel
4) root user-space process (init and inittab)
5) boot scripts

对系统启动时间优化，即对这些步骤进行优化

启动时间的测量
---------------

linux中可以有多种方式获取系统的启动时间

- printk times : 用于显示每个printk的执行时间
- 内核函数跟踪(Ftrace) : 用于报告内核中每个函数的调用时间
- linux跟踪工具箱(LTT) ： 用于报告确切的内核和进程事件的时间数据
- perf : 通用的linux分析器(profile)
- Bootchart : 用于linux 启动过程的性能分析和数据显示，收集启动过程中的用户空间部分的资源使用情况和进程信息，然后渲染成PNG,SVG或者EPS格式的图表
- Bootprobe : 一组用于分析系统启动过程的system tap脚本
- cat /proc/uptime : 统计系统已经运行的时间
- grabserial : 用于记录控制台输出并打上时间戳

启动时间优化技巧
-----------------

bootloader加速
^^^^^^^^^^^^^^^^^

- 就地执行(XIP)内核： 允许内核在ROM或者FLASH上就地执行
- 在启动时通过DMA拷贝内核镜像 : 使用DMA从闪存中拷贝内核到内存
- 采用未压缩的内核
- 快速内核解压
- 关闭不需要的功能 ：比如关闭引导程序输出 ，关闭延迟启动, 删除网络加载

内核加速
^^^^^^^^^

- 关闭控制台 : 避免启动过程中的控制台输出开销
- 关闭调试接口和printk : 避免调试接口和printk带来的开销，缺点是丢失大量调试信息
- 不同步RTC : 避免在启动时延迟用RTC时钟边沿同步系统时间
- 异步函数调用 : 允许probe函数或者其他函数并行处理
- 重新排序驱动初始化过程 

文件系统方面的问题
^^^^^^^^^^^^^^^^^^

对于同样的数据集，不同的文件系统拥有不同的初始化(即挂载，mounting)时间，这取决于元数据(meta-data)是否必须从存储器读到内存并且在挂载过程中使用哪种算法

如果挂载一个文件系统耗费太久，那么可以考虑把一个文件系统拆分成几个部分，一部分带有在启动时或者启动后立即需要的信息，另外一些部分则可以延迟挂载


用户空间和应用程序加速
^^^^^^^^^^^^^^^^^^^^^^^

- 优化RC脚本 ：减少执行RC脚本的开销
- 并行执行RC脚本 
- 预链接 ：避免在首次加载程序时进行链接
- 静态链接应用程序 : 这样可以避免运行时链接，如果应用程序少的话这种方式是可行的
- 应用程序优化
- 把驱动模块编译到内核镜像中
- 避免使用udev : 因为它花费一些时间来构建/dev目录，在嵌入式系统中通常会事先知道需要哪些设备，所以我们可以采取静态预先创建设备节点
- 如果有设备连接网络，最好使用静态IP，通过DHCP获取地址会增加时间


